---
title: 单例模式及其实现
date: 2019-05-06 06:56:45
tags:
- Python
- 设计模式
categories:
- 杂谈
---
## 什么是单例模式

单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。

实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。

单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。

## 实现单例模式

### 使用模块实现

ython模块在初次导入时会生成*.pyc字节码文件，以后的每次导入都不会再次执行模块代码，因此，我们只需把相关的代码放入到一个模块中，就可以得到一个单例对象，可以考虑这样做

```Python
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass
my_singleton = My_Singleton()
```

### 使用__new__

为了使类只能出现一个实例，我们可以使用 __new__ 来控制实例的创建过程，代码如下：

```Python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)
        return cls._instance


class MyClass(Singleton):
    pass


one = MyClass()
two = MyClass()

print(one == two)
print(one is two)

```

在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance

### 使用装饰器

我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：

```Python
from functools import wraps


def singleton(cls):
    instances = {}

    @wraps(cls)
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance


@singleton
class MyClass(object):
    pass


one = MyClass()
two = MyClass()
print(one == two)
print(one is two)

```

### 使用metaclass

元类（metaclass）可以控制类的创建过程，它主要做三件事：

1. 拦截类的创建
2. 修改类的定义
3. 返回修改后的类
使用元类实现单例模式的代码如下：

```Python
class Singleton(type):
    _instance = None

    def __call__(cls, *args, **kwargs):
        if not cls._instance:
            cls._instance = cls._instance = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instance


class MyClass(metaclass=Singleton):
    pass


# Python2
# class MyClass(object):
#     __metaclass__ = Singleton


one = MyClass()
two = MyClass()
print(one == two)
print(one is two)

```

参考:[Python中的单例模式](https://funhacks.net/2017/01/17/singleton/)
