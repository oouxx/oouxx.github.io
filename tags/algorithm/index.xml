<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on wxx&#39;s blog</title>
    <link>http://localhost:1313/tags/algorithm/</link>
    <description>Recent content in algorithm on wxx&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 04 Dec 2018 10:25:50 +0800</lastBuildDate>
    
	<atom:link href="http://localhost:1313/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BF算法C&#43;&#43;版</title>
      <link>http://localhost:1313/post/bruteforcealgoritmc&#43;&#43;ver/</link>
      <pubDate>Tue, 04 Dec 2018 10:25:50 +0800</pubDate>
      
      <guid>http://localhost:1313/post/bruteforcealgoritmc&#43;&#43;ver/</guid>
      <description>这是字符串暴力匹配算法的C_++版本 暴力匹配的思路:使用穷举的方法,目标串和模式串进行匹配,一旦失配,目标串指针(或者说数组索引值)回退到下</description>
    </item>
    
    <item>
      <title>KMP算法C&#43;&#43;版</title>
      <link>http://localhost:1313/post/kmpalgorithmc&#43;&#43;ver/</link>
      <pubDate>Tue, 04 Dec 2018 10:25:50 +0800</pubDate>
      
      <guid>http://localhost:1313/post/kmpalgorithmc&#43;&#43;ver/</guid>
      <description>KMP算法C++版本 KMP算法基本思路:构造next[]减少回溯 next的构造 1 2 3 4 5 6 7 8 9 10 11 12 void GetNext(SqString t, int next[]){ int j,k; j=0;k=-1; next[0] = -1; while(j &amp;lt; t.length-1){ if(k==-1 || t.data[j]==t.data[k]){ j++;k++; next[i]=k;</description>
    </item>
    
    <item>
      <title>快速排序Java版简单示例.md</title>
      <link>http://localhost:1313/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fjava%E7%89%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</link>
      <pubDate>Sat, 01 Dec 2018 18:34:38 +0800</pubDate>
      
      <guid>http://localhost:1313/post/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fjava%E7%89%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.util.Scanner; public class Main{ public static void main(String[] args){ Scanner sc = new Scanner(System.in); int n = sc.nextInt(); int[] array = new int[n]; for(int i=0;i&amp;lt;n;i++){ array[i] = sc.nextInt();</description>
    </item>
    
    <item>
      <title>leetcode-AddTwoNumbers.md</title>
      <link>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-addtwonumbers/</link>
      <pubDate>Fri, 23 Nov 2018 20:08:55 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-addtwonumbers/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 1 2 3 Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt;</description>
    </item>
    
    <item>
      <title>leetcode刷题记--RomamToInteger.md</title>
      <link>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-romamtointeger/</link>
      <pubDate>Thu, 22 Nov 2018 16:13:24 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-romamtointeger/</guid>
      <description>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. 1 2 3 4 5 6 7 8 Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven</description>
    </item>
    
    <item>
      <title>leetcode--ThreeSum.md</title>
      <link>http://localhost:1313/post/leetcode-threesum/</link>
      <pubDate>Sat, 17 Nov 2018 18:38:54 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode-threesum/</guid>
      <description>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 1</description>
    </item>
    
    <item>
      <title>Python的Bunch模式</title>
      <link>http://localhost:1313/post/python%E7%9A%84bunch%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 30 Oct 2018 21:41:57 +0800</pubDate>
      
      <guid>http://localhost:1313/post/python%E7%9A%84bunch%E6%A8%A1%E5%BC%8F/</guid>
      <description>Python的Bunch模式 今天在看Python algorithm，看到了这个东西，感觉会很有用，赶快拿起vim码起字来分享给大家。我也粗略</description>
    </item>
    
    <item>
      <title>leetcode刷题记--LongestCommonPrefix-续</title>
      <link>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-longestcommonprefix-%E7%BB%AD/</link>
      <pubDate>Fri, 26 Oct 2018 21:36:42 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-longestcommonprefix-%E7%BB%AD/</guid>
      <description>解法剖析 来自leetcode 具体的内容我就不复制粘贴了，只讲一下我对每种解法的理解 Horizontal scanning 1 2 3 4 5 6 7 8 9 10 public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return &amp;#34;&amp;#34;; String prefix = strs[0]; for (int</description>
    </item>
    
    <item>
      <title>leetcode刷题记--LongestCommonPrefix</title>
      <link>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-longestcommonprefix/</link>
      <pubDate>Thu, 25 Oct 2018 15:49:35 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-longestcommonprefix/</guid>
      <description>Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &amp;ldquo;&amp;quot;. Example 1: 1 2 Input: [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] Output: &amp;#34;fl&amp;#34; Example 2: 1 2 3 Input: [&amp;#34;dog&amp;#34;,&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] Output: &amp;#34;&amp;#34; Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. My Answer: 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>leetcode刷题记--ReverseInteger-续</title>
      <link>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-reverseinteger-%E7%BB%AD/</link>
      <pubDate>Wed, 24 Oct 2018 08:30:00 +0800</pubDate>
      
      <guid>http://localhost:1313/post/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0-reverseinteger-%E7%BB%AD/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution: def reverse(self, x): # 取出符号位 sign = -1 if x&amp;lt;0 else 1 # 把x化为正数 x*=sign rev = 0 while not x==0: rev*=10 rev += x%10 x = x//10 if not -2**31&amp;lt;=rev&amp;lt;=2**31-1: return 0 return rev*sign 上面代码是在lee</description>
    </item>
    
  </channel>
</rss>